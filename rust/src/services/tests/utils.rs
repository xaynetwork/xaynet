use crate::{
    crypto::{ByteObject, EncryptKeyPair, PublicEncryptKey, SigningKeyPair},
    message::{MessageOwned, MessageSeal, SumOwned},
    state_machine::{
        coordinator::{RoundParameters, RoundSeed},
        events::{EventPublisher, EventSubscriber, PhaseEvent},
    },
    SumParticipantEphemeralPublicKey,
};

/// Create an [`EventPublisher`]/[`EventSubscriber`] pair with default
/// values similar to those produced in practice when instantiating a
/// new coordinator.
pub fn new_event_channels() -> (EventPublisher, EventSubscriber) {
    let keys = EncryptKeyPair::generate();
    let params = RoundParameters {
        pk: keys.public.clone(),
        sum: 0.0,
        update: 0.0,
        seed: RoundSeed::generate(),
    };
    let phase = PhaseEvent::Idle;
    EventPublisher::init(keys, params, phase)
}

/// Simulate a participant generating keys and crafting a valid sum
/// message for the given round parameters. The keys generated by the
/// participants are returned along with the message.
pub fn new_sum_message(
    round_params: &RoundParameters,
) -> (
    MessageOwned,
    SumParticipantEphemeralPublicKey,
    SigningKeyPair,
) {
    let participant_ephm_pk = PublicEncryptKey::generate();
    let participant_signing_keys = SigningKeyPair::generate();

    let sum_signature = participant_signing_keys
        .secret
        .sign_detached(&[round_params.seed.as_slice(), b"sum"].concat());
    let payload = SumOwned {
        sum_signature,
        ephm_pk: participant_ephm_pk,
    };

    let message = MessageOwned::new_sum(
        round_params.pk.clone(),
        participant_signing_keys.public.clone(),
        payload,
    );

    (message, participant_ephm_pk, participant_signing_keys)
}

/// Sign and encrypt the given message using the given round
/// parameters and particpant keys.
pub fn encrypt_message(
    message: &MessageOwned,
    round_params: &RoundParameters,
    participant_signing_keys: &SigningKeyPair,
) -> Vec<u8> {
    let seal = MessageSeal {
        recipient_pk: &round_params.pk,
        sender_sk: &participant_signing_keys.secret,
    };
    let encrypted_message = seal.seal(&message);

    encrypted_message
}
